### 7.5 基于 IDF 组件快速实现本地控制模块

ESP-IDF 中的 ESP 本地控制 (esp_local_ctrl) 组件提供了通过 Wi-Fi + HTTPS 或 BLE 控制 ESP 设备的功能。 它提供对应用程序定义的属性的访问，这些属性可通过一组可配置的处理程序进行读/写。 

本章主要介绍的是基于 Wi-Fi 传输的本地控制模块。它包含：

- 本地设备发现 mdns 协议功能配置
- 本地数据通信协议 HTTPS 服务器与证书配置

用户只需调用相关封装的接口，便能实现本地控制模块。

#### 7.5.1 esp_local_ctrl 组件创建服务端

```c
#define PROPERTY_NAME_STATUS "status"
static char light_status[64] = "{\"status\": true}";
/* 属性类型定义，配合脚本使用 */
enum property_types {
    PROP_TYPE_TIMESTAMP = 0,
    PROP_TYPE_INT32,
    PROP_TYPE_BOOLEAN,
    PROP_TYPE_STRING,
};

/* 获取属性值 */
esp_err_t get_property_values(size_t props_count,
                              const esp_local_ctrl_prop_t props[],
                              esp_local_ctrl_prop_val_t prop_values[],
                              void *usr_ctx)
{
    int i = 0;
    for (i = 0; i < props_count; i ++) {
        ESP_LOGI(TAG, "Reading property : %s", props[i].name);
        if (!strncmp(PROPERTY_NAME_STATUS, props[i].name, strlen(props[i].name))) {
            prop_values[i].size = strlen(light_status);
            prop_values[i].data = &light_status;/* prop_values[i].data 只是指针，不能赋值 */
            break;
        }
    }
    if (i == props_count) {
        ESP_LOGE(TAG, "Not found property %s", props[i].name);
        return ESP_FAIL;
    }
    return ESP_OK;
}

/* 设置属性值 */
esp_err_t set_property_values(size_t props_count,
                              const esp_local_ctrl_prop_t props[],
                              const esp_local_ctrl_prop_val_t prop_values[],
                              void *usr_ctx)
{
    int i = 0;
    for (i = 0; i < props_count; i ++) {
        ESP_LOGI(TAG, "Setting property : %s", props[i].name);
        if (!strncmp(PROPERTY_NAME_STATUS, props[i].name, strlen(props[i].name))) {
            memset(light_status, 0, sizeof(light_status));
            strncpy(light_status, (const char *)prop_values[i].data, prop_values[i].size);
            break;
        }
    }
    if (i == props_count) {
        ESP_LOGE(TAG, "Not found property %s", props[i].name);
        return ESP_FAIL;
    }
    return ESP_OK;
}

#define SERVICE_NAME "my_esp_ctrl_device"

void esp_local_ctrl_service_start(void)
{
    /* 初始化 HTTPS 服务端配置 */
    httpd_ssl_config_t https_conf = HTTPD_SSL_CONFIG_DEFAULT();

    /* 加载服务端证书 */
    extern const unsigned char cacert_pem_start[] asm("_binary_cacert_pem_start");
    extern const unsigned char cacert_pem_end[]   asm("_binary_cacert_pem_end");
    https_conf.cacert_pem = cacert_pem_start;
    https_conf.cacert_len = cacert_pem_end - cacert_pem_start;

    /* 加载服务端私钥 */
    extern const unsigned char prvtkey_pem_start[] asm("_binary_prvtkey_pem_start");
    extern const unsigned char prvtkey_pem_end[]   asm("_binary_prvtkey_pem_end");
    https_conf.prvtkey_pem = prvtkey_pem_start;
    https_conf.prvtkey_len = prvtkey_pem_end - prvtkey_pem_start;

    esp_local_ctrl_config_t config = {
        .transport = ESP_LOCAL_CTRL_TRANSPORT_HTTPD,
        .transport_config = {
            .httpd = &https_conf
        },
        .proto_sec = {
            .version = PROTOCOM_SEC0,
            .custom_handle = NULL,
            .pop = NULL,
        },
        .handlers = {
            /* 用户自定义处理函数 */
            .get_prop_values = get_property_values,
            .set_prop_values = set_property_values,
            .usr_ctx         = NULL,
            .usr_ctx_free_fn = NULL
        },
        /* 设置属性最大个数 */
        .max_properties = 10
    };

    /* 初始化本地发现 */
    mdns_init();
    mdns_hostname_set(SERVICE_NAME);

    /* 启动本地控制服务 */
    ESP_ERROR_CHECK(esp_local_ctrl_start(&config));
    ESP_LOGI(TAG, "esp_local_ctrl service started with name : %s", SERVICE_NAME);

    esp_local_ctrl_prop_t status = {
        .name        = PROPERTY_NAME_STATUS,
        .type        = PROP_TYPE_STRING,
        .size        = 0,
        .flags       = 0,
        .ctx         = NULL,
        .ctx_free_fn = NULL
    };

    /* 添加属性值 */
    ESP_ERROR_CHECK(esp_local_ctrl_add_property(&status));
}
```

上述示例代码实现了通过本地发现（MDNS）发现域名为 `my_esp_ctrl_device.local` 的设备，建立 HTTPS 的本地控制连接，客户端可以使用注册的端点进行属性值的设置和查询。

您可以使用以下选项在 ESP 本地控制中为传输设置安全性：

- PROTOCOM_SEC0：指定使用端到端加密
- PROTOCOM_SEC1：指定数据将作为纯文本交换
- PROTOCOM_SEC_CUSTOM：自定义安全要求

**属性创建**

每个属性必须具有唯一的名称（字符串）、类型（例如： int、bool、string 类型）、标志（例如： 只可读、可读可写）和大小。

如果我们希望我们的属性值具有可变长度（例如，如果它是一个字符串或字节流），则大小应保持为 0。 对于固定长度的属性值数据类型，如 int、float 等，将 size 字段设置为正确的值，有助于 esp_local_ctrl 对通过写入请求接收到的参数执行内部检查。

**属性处理函数**

我们可以根据 `props[i].name` 来匹配对应的属性名来进行处理，处理的时候可以根据属性的 flag 和 type 进行进一步的校验，看这个属性是否满足对应的 flag 和 type。

**默认端点**

|端点名字 (BLE + GATT Server)  | URI (HTTPS Server + mDNS)  | 描述 |
| :----: | :----: | :----: |
| esp_local_ctrl/version | https://<mdns-hostname>.local/esp_local_ctrl/version | 用于检索版本字符串的端点 |
| esp_local_ctrl/control | https://<mdns-hostname>.local/esp_local_ctrl/control | 用于发送/接收控制消息的端点 |

#### 7.5.2 使用脚本验证本地控制功能

讲完了如何创建本地控制模块，接下来我们讲如何使用脚本工具进行验证。

我们使用官方示例 esp_local_ctrl 里的[脚本工具](https://github.com/espressif/esp-idf/tree/master/examples/protocols/esp_local_ctrl/scripts)进行验证。

首先我们需要创建客户端和服务器进行 TLS 握手的证书：

1. 我们生成一个 rootCA，我们将使用它来签署服务器证书，并且客户端将在 SSL 握手期间使用它来验证服务器证书。 您需要设置一个密码来加密生成的 `rootkey.pem`。

```
openssl req -new -x509 -subj "/CN=root" -days 3650 -sha256 -out rootCA.pem -keyout rootkey.pem
```

2. 现在为服务器生成一个证书签名请求，以及它的私钥`prvtkey.pem`。

```
openssl req -newkey rsa:2048 -nodes -keyout prvtkey.pem -days 3650 -out server.csr -subj "/CN=my_esp_ctrl_device.local"
```

3. 现在使用之前生成的rootCA来处理服务器的证书签名请求，生成签名证书`cacert.pem`。 在此步骤中必须输入之前为加密 rootkey.pem 设置的密码。

```
openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootkey.pem -CAcreateserial -out cacert.pem -days 500 -sha256
```

生成的这些证书里，`cacert.pem` 和 `prvtkey.pem` 是编译进服务端的，`rootkey.pem` 适用于客户端脚本进行服务器校验的。该证书的目录可以在脚本 `esp_local_ctrl.py` 里设置。

```python
def get_transport(sel_transport, service_name, check_hostname):
...
    example_path = os.environ['IDF_PATH'] + '/examples/protocols/esp_local_ctrl'
    cert_path = example_path + '/main/certs/rootCA.pem'
...
```

使用如下命令进行脚本连接本地控制服务器，`sec_ver` 为 0 是服务器侧设置了 `PROTOCOM_SEC0`

```
python esp_local_ctrl.py --sec_ver 0
```

脚本自动获取属性值

```
Connecting to my_esp_ctrl_device.local

==== Starting Session ====
==== Session Established ====

==== Available Properties ====
S.N. Name             Type       Flags            Value           
[ 1] status           STRING                      {"status": true}
```

根据脚本提示，输入属性编号 `1`，设置属性值 `{"status": false}`，设置完后，脚本自动查询，此时发现值已经更改完成

```
Select properties to set (0 to re-read, 'q' to quit) : 1
Enter value to set for property (status) : {"status": false}

==== Available Properties ====
S.N. Name             Type       Flags            Value           
[ 1] status           STRING                      {"status": false}

Select properties to set (0 to re-read, 'q' to quit) : 
```
