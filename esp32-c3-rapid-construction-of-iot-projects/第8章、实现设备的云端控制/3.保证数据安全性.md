### 8.3 如何保证数据安全性 TLS

MQTT 消息的负载是以明文传输的，所以如果不进行加密的话，数据很容易就被窃取。我们在介绍本地控制的时候有介绍过 TLS 协议，它能保证数据只有通信双方才能解密，保证了数据的安全性与合法性。

同样，我们使用 MQTT 协议进行云端控制通信时，也可以借助 TLS 协议。下面我们介绍如何基于本地 MQTT Broker 搭建双向认证的 TLS 环境。

#### 8.3.1 生成证书所需的私钥 KEY

生成 CA 证书 2048 位私钥 KEY

```
$ openssl genrsa -out ca.key 2048
Generating RSA private key, 2048 bit long modulus
...........................................................................................................................+++
.......+++
e is 65537 (0x10001)
```

生成服务器证书 2048 位私钥 KEY
```
$ openssl genrsa -out server.key 2048
Generating RSA private key, 2048 bit long modulus
................+++
........................+++
e is 65537 (0x10001)
```

生成客户端证书 2048 位私钥 KEY
```
$ openssl genrsa -out client.key 2048
Generating RSA private key, 2048 bit long modulus
...............................................+++
........................................................+++
e is 65537 (0x10001)
```

RSA 算法长度建议最少是 2048 位，如果是 1024 位的话，mbedtls 会以安全性过低拒绝 TLS 协商。

#### 8.3.2 生成证书所需的 CSR

生成 CA 证书所需的 CSR，按照提示输入即可，需要输入 Organization Name，随意输入，因为这些都只是在本地使用。

```
$ openssl req -out ca.csr -key ca.key -new
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:IOT Certificate Test
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
```

生成服务器证书所需要的 CSR，注意这边需要输入 `Common Name` 字段，一般写服务器本身的域名或者 IP 地址。

```
$ openssl req -out server.csr -key server.key -new
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:MQTT Server
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:192.168.3.4
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
```

同样生成客户端证书所需要的 CSR，`Common Name` 填客户端的 IP。

```
$ openssl req -out client.csr -key client.key -new
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:
Locality Name (eg, city) []:
Organization Name (eg, company) [Internet Widgits Pty Ltd]:MQTT Client
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:192.168.3.5
Email Address []:

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
```

#### 8.3.3 生成 CA，服务器，客户端证书

生成 CA 证书 ca.crt

```
$ openssl x509 -req -in ca.csr -out ca.crt -sha256 -days 5000 -signkey ca.key
Signature ok
subject=/C=CN/ST=Some-State/O=IOT Certificate Test
Getting Private key

```

生成服务器证书 server.crt

```
$ openssl x509 -req -in server.csr -out server.crt -sha256 -CAcreateserial -days 5000 -CA ca.crt -CAkey ca.key
Signature ok
subject=/C=CN/ST=Some-State/O=MQTT Server/CN=192.168.3.4
Getting CA Private Key
```

生成客户端证书 client.crt

```
$ openssl x509 -req -in client.csr -out client.crt -sha256 -CAcreateserial -days 5000 -CA ca.crt -CAkey ca.key
Signature ok
subject=/C=CN/ST=Some-State/O=MQTT Client/CN=192.168.3.5
Getting CA Private Key
```

注意不要使用 sha1 算法，因为对于 mbedtls 而言，安全性过低，同样会拒绝 TLS 协商。

#### 8.3.4 配置 MQTT Broker

我们在上一章 8.2.4.1 节介绍了如何基于 Linux 安装搭建 mosquitto。这一节介绍如何使能 mosquitto + TLS。

首先修改配置文件 `mosquitto.conf`，这个文件在 mosquitto 的根目录。在该文件中添加如下配置，配置上一节我们生成的 CA 证书绝对路径（ca.crt）,服务器证书绝对路径（server.crt）和服务器证书私钥（server.key）

```
port 8883
certfile {绝对路径}/server.crt
keyfile {绝对路径}/server.key
cafile {绝对路径}/ca.crt
require_certificate true
use_identity_as_username true
```

配置结束后需要重新启动 mosquitto，并且加载配置文件

```
$ mosquitto -c mosquitto.conf -v
1635927859: mosquitto version 1.6.3 starting
1635927859: Config loaded from mosquitto.conf.
1635927859: Opening ipv4 listen socket on port 8883.
1635927859: Opening ipv6 listen socket on port 8883.
```

#### 8.3.5 配置 ESP-MQTT 客户端

上一章 8.2.5 我们介绍了如何基于 IDF 创建 MQTT 客户端，之前使用的是 MQTT + TCP 传输，由于数据安全性不能保证，我们本章介绍如何使用 MQTT + TLS 创建客户端进行传输。

```c
extern const uint8_t client_cert_pem_start[] asm("_binary_client_crt_start");
extern const uint8_t client_cert_pem_end[] asm("_binary_client_crt_end");
extern const uint8_t client_key_pem_start[] asm("_binary_client_key_start");
extern const uint8_t client_key_pem_end[] asm("_binary_client_key_end");
extern const uint8_t server_cert_pem_start[] asm("_binary_ca_crt_start");
extern const uint8_t server_cert_pem_end[] asm("_binary_ca_crt_end");

#define CONFIG_BROKER_URL "mqtts://192.168.3.4/"

/* 配置 MQTT URI */
esp_mqtt_client_config_t mqtt_cfg = {
    .uri = CONFIG_BROKER_URL,
    .client_cert_pem = (const char *)client_cert_pem_start,
    .client_key_pem = (const char *)client_key_pem_start,
    .cert_pem = (const char *)server_cert_pem_start,
};
```

我们需要加载客户端的证书（client.crt），客户端私钥（client.key）和认证服务器的 CA 证书（ca.crt），修改原先 MQTT 连接为 `mqtts`，默认会使用端口 `8883`.

除了代码上加载证书以外，我们还需要修改 CMake 文件，在编译的时候将证书加载进固件里。

```
target_add_binary_data(${CMAKE_PROJECT_NAME}.elf "main/client.crt" TEXT)
target_add_binary_data(${CMAKE_PROJECT_NAME}.elf "main/client.key" TEXT)
target_add_binary_data(${CMAKE_PROJECT_NAME}.elf "main/ca.crt" TEXT)
```

编译烧录后，设备连接 WIFI，可以看到客户端和服务器显示连接成功，并且客户端订阅了主题 `/topic/test`。

如下是服务器端的日志

```
1635927859: mosquitto version 1.6.3 starting
1635927859: Config loaded from mosquitto.conf.
1635927859: Opening ipv4 listen socket on port 8883.
1635927859: Opening ipv6 listen socket on port 8883.
1635927867: New connection from 192.168.3.5 on port 8883.
1635927869: New client connected from 192.168.3.5 as ESP32_2465F1 (p2, c1, k120, u'192.168.3.5').
1635927869: No will message specified.
1635927869: Sending CONNACK to ESP32_2465F1 (0, 0)
1635927869: Received SUBSCRIBE from ESP32_2465F1
1635927869: 	/topic/test (QoS 0)
1635927869: ESP32_2465F1 0 /topic/test
1635927869: Sending SUBACK to ESP32_2465F1
```

现在我们使用 mosquitto_pub 向 topic `/topic/test` 发送数据 `hello world`，看设备是否可以接收到。

```
mosquitto_pub -h 192.168.3.4 -p 8883 -t "/topic/test" -m 'hello world' --cafile ca.crt --cert client.crt --key client.key
```

设备侧日志如下

```
I (1600) esp_netif_handlers: sta ip: 192.168.3.5, mask: 255.255.255.0, gw: 192.168.3.1
I (1600) wifi station: got ip:192.168.3.5
I (1600) wifi station: connected to ap SSID:HUAWEI_WS5200_YJM_1 password:12345678
I (1610) wifi station: Other event id:7
W (1630) wifi:<ba-add>idx:0 (ifx:0, 34:29:12:43:c5:40), tid:0, ssn:4, winSize:64
I (4110) wifi station: MQTT_EVENT_CONNECTED
I (4120) wifi station: sent subscribe successful, msg_id=42634
I (4140) wifi station: MQTT_EVENT_SUBSCRIBED, msg_id=42634
I (10290) wifi station: MQTT_EVENT_DATA
I (10290) wifi station: TOPIC=/topic/test
I (10290) wifi station: DATA=hello world
```

至此，我们介绍了如何基于本地 mosquitto 工具搭建安全的 MQTTS 环境以及如何使 ESP-MQTT 结合 TLS 安全的传输数据。