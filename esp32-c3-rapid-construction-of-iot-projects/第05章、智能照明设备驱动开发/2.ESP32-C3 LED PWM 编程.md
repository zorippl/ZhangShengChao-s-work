# ESP32-C3 LED PWM 编程

设置 LEDC 通道分三步完成。

- 定时器配置： 指定 PWM 信号的频率和占空比分辨率。
- 通道配置： 绑定定时器和输出 PWM 信号的 GPIO。
- 改变 PWM 信号： 输出 PWM 信号来驱动 LED。可通过软件控制或使用硬件渐变功能来改变 LED 的亮度。

<div align="center">
    <img src="./assets/1_8.jpg" width = "1000" alt="1_8" align=center />
</div>

## 定时器配置

要设置定时器，可调用函数 `ledc_timer_config()`，并将包括如下配置参数的数据结构 `ledc_timer_config_t` 传递给该函数：

- 速度模式（值必须为 LEDC_LOW_SPEED_MODE）
- 定时器索引 `ledc_timer_t`
- PWM 信号频率
- PWM 占空比分辨率

频率和占空比分辨率相互关联。PWM 频率越高，占空比分辨率越低，反之亦然。如果 API 不是用来改变 LED 亮度，而是用于其它目的，这种相互关系可能会很重要。更多信息详见 频率和占空比分辨率支持范围 一节。

## 通道配置

定时器设置好后，请配置所需的通道（`ledc_channel_t` 之一）。配置通道需调用函数 `ledc_channel_config()`。

通道的配置与定时器设置类似，需向通道配置函数传递包括通道配置参数的结构体 `ledc_channel_config_t` 。

此时，通道会按照 `ledc_channel_config_t` 的配置开始运作，并在选定的 GPIO 上生成由定时器设置指定的频率和占空比的 PWM 信号。在通道运作过程中，可以随时通过调用函数 `ledc_stop()` 将其暂停。

## 改变 PWM 信号

通道开始运行、生成具有恒定占空比和频率的 PWM 信号之后，有几种方式可以改变该信号。驱动 LED 时，主要通过改变占空比来变化光线亮度。

以下两节介绍了如何使用软件和硬件改变占空比。

1. 使用软件改变 PWM 占空比

    调用函数 `ledc_set_duty()` 可以设置新的占空比。之后，调用函数 `ledc_update_duty()` 使新配置生效。要查看当前设置的占空比，可使用 _get_ 函数 `ledc_get_duty()`。

    另外一种设置占空比和其他通道参数的方式是调用 通道配置 一节提到的函数 `ledc_channel_config()`。

    传递给函数的占空比数值范围取决于选定的 duty_resolution，应为 0 至 (2 ** duty_resolution) - 1。例如，如选定的占空比分辨率为 10，则占空比的数值范围为 0 至 1023。此时分辨率为 ~0.1%。

2. 使用硬件改变 PWM 占空比

    LED PWM 控制器硬件可逐渐改变占空比的数值。要使用此功能，需用函数 `ledc_fade_func_install()` 使能渐变，之后用下列可用渐变函数之一配置：

    - `ledc_set_fade_with_time()`
    - `ledc_set_fade_with_step()`
    - `ledc_set_fade()`

    最后用 `ledc_fade_start()` 开启渐变。

    如不需要渐变和渐变中断，可用函数 `ledc_fade_func_uninstall()` 关闭。

## 频率和占空比分辨率支持范围

LED PWM 控制器主要用于驱动 LED。该控制器 PWM 占空比设置的分辨率范围较广。比如，PWM 频率为 5 kHz 时，占空比分辨率最大可为 13 位。这意味着占空比可为 0 至 100% 之间的任意值，分辨率为 ~0.012%（2 ** 13 = 8192 LED 亮度的离散电平）。然而，这些参数取决于为 LED PWM 控制器定时器计时的时钟信号，LED PWM 控制器为通道提供时钟。

LED PWM 控制器可用于生成频率较高的信号，足以为数码相机模组等其他设备提供时钟。此时，最大频率可为 40 MHz，占空比分辨率为 1 位。也就是说，占空比固定为 50%，无法调整。

LED PWM 控制器 API 会在设定的频率和占空比分辨率超过 LED PWM 控制器硬件范围时报错。例如，试图将频率设置为 20 MHz、占空比分辨率设置为 3 位时，串行端口监视器上会报告如下错误：

```
E (196) ledc: requested frequency and duty resolution cannot be achieved, try reducing freq_hz or duty_resolution. div_param=128
```

此时，占空比分辨率或频率必须降低。比如，将占空比分辨率设置为 2 会解决这一问题，让占空比设置为 25% 的倍数，即 25%、50% 或 75%。

如设置的频率和占空比分辨率低于所支持的最低值，LED PWM 驱动器也会反映并报告，如：

```
E (196) ledc: requested frequency and duty resolution cannot be achieved, try increasing freq_hz or duty_resolution. div_param=128000000
```

占空比分辨率通常用 `ledc_timer_bit_t` 设置，范围是 10 至 15 位。如需较低的占空比分辨率（上至 10，下至 1），可直接输入相应数值。

# 智能照明项目实例

在本书中的智能照明项目中，LED 灯包含 Red（红）、Green（绿）、Blue（蓝）、Warm（暖光）、Cold（冷光） 五种不同颜色，所以我们需要五个 LED PWM 通道。实际应用中对 LED 灯的功能需求有：开关灯、HSV 颜色空间控制、HSL 颜色空间控制、色温亮度控制、呼吸灯、渐变状态等。

## light_driver 组件

在该智能项目中，将 LED 调光驱动封装到 `light_driver` 组件中。为主应用提供的 API 有：

- `esp_err_t light_driver_init(light_driver_config_t *config);`: 初始化 light_driver 驱动
- `esp_err_t light_driver_deinit(void);`: 去初始化 light_driver 驱动
- `esp_err_t light_driver_config(uint32_t fade_period_ms, uint32_t blink_period_ms);`: 配置 light_driver 驱动渐变时间和闪烁周期
- `esp_err_t light_driver_set_switch(bool status);`: 打开
- `bool light_driver_get_switch(void);`: 关闭
- `esp_err_t light_driver_set_hue(uint16_t hue);`: 设置 Hue 色调
- `uint16_t light_driver_get_hue(void);`: 获取 Hue 色调
- `esp_err_t light_driver_set_saturation(uint8_t saturation);`: 设置 Saturation 饱和度
- `uint8_t light_driver_get_saturation(void);`: 获取 Saturation 饱和度
- `esp_err_t light_driver_set_value(uint8_t value);`: 设置 Value 明度
- `uint8_t light_driver_get_value(void);`: 获取 Value 明度
- `esp_err_t light_driver_set_hsv(uint16_t hue, uint8_t saturation, uint8_t value);`: 同时设置 HSV 三个值
- `esp_err_t light_driver_get_hsv(uint16_t *hue, uint8_t *saturation, uint8_t *value);`: 同时获取 HSV 三个值
- `esp_err_t light_driver_set_lightness(uint8_t lightness);`: 设置 Lightness 亮度
- `uint8_t light_driver_get_lightness(void);`: 获取  Lightness 亮度
- `esp_err_t light_driver_set_hsl(uint16_t hue, uint8_t saturation, uint8_t lightness);`: 同时设置 HSL 三个值
- `esp_err_t light_driver_get_hsl(uint16_t *hue, uint8_t *saturation, uint8_t *lightness);`: 同时获取 HSL 三个值
- `esp_err_t light_driver_set_color_temperature(uint8_t color_temperature);`: 设置色温
- `uint8_t light_driver_get_color_temperature(void);`: 获取色温
- `esp_err_t light_driver_set_brightness(uint8_t brightness);`: 设置 Brightness 亮度
- `uint8_t light_driver_get_brightness(void);`: 获取 Brightness 亮度
- `esp_err_t light_driver_set_ctb(uint8_t color_temperature, uint8_t brightness);`: 同时设置色温、亮度两个值
- `esp_err_t light_driver_get_ctb(uint8_t *color_temperature, uint8_t *brightness);`: 同时获取色温、亮度两个值
- `esp_err_t light_driver_set_rgb(uint8_t red, uint8_t green, uint8_t blue);`: 同时设置 RGB 三个值
- `esp_err_t light_driver_breath_start(uint8_t red, uint8_t green, uint8_t blue);`: 设置呼吸状态的颜色，并开始呼吸状态
- `esp_err_t light_driver_breath_stop(void);`: 停止呼吸状态
- `esp_err_t light_driver_blink_start(uint8_t red, uint8_t green, uint8_t blue);`: 设置渐变状态的颜色，并开始渐变状态
- `esp_err_t light_driver_blink_stop(void);`: 停止渐变状态


## 驱动初始化

驱动初始化时，需要提供 `light_driver_config_t` 参数，该参数指明了使用的 ESP32-C3 的 GPIO 引脚、渐变时间、呼吸灯周期、PWM 频率、LED PWM 控制器时钟源、PWM 占空比分辨率等。

```c
/**
    * @brief Light driver initialization
    */
light_driver_config_t driver_config = {
    .gpio_red        = LIGHT_GPIO_RED,
    .gpio_green      = LIGHT_GPIO_GREEN,
    .gpio_blue       = LIGHT_GPIO_BLUE,
    .gpio_cold       = LIGHT_GPIO_COLD,
    .gpio_warm       = LIGHT_GPIO_WARM,
    .fade_period_ms  = LIGHT_FADE_PERIOD_MS,
    .blink_period_ms = LIGHT_BLINK_PERIOD_MS,
    .freq_hz         = LIGHT_FREQ_HZ,
    .clk_cfg         = LEDC_USE_APB_CLK,
    .duty_resolution = LEDC_TIMER_11_BIT,
};
ESP_ERROR_CHECK(light_driver_init(&driver_config));
```

## LED 灯控制

1. 开关控制

在完成 LED 调光驱动初始化后，应用层就可以开始对 LED 进行控制了。下面的 API 是对 LED 进行开关控制：

```c
// light on
light_driver_set_switch(true);
// light off
light_driver_set_switch(false);
```

2. 颜色控制

在完成 LED 调光驱动初始化，在开灯的情况下，可以对 LED 进行颜色控制，可以通过 RGB 颜色空间或 HSL 颜色空间或 HSV 颜色空间：

使用 API 时，需要注意他们的参数取值范围：

- HSV(hue <= 360，saturation <= 100，value <= 100);
- HSL(hue <= 360，saturation <= 100，lightness <= 100);
- RGB(red <= 255，green <= 255，blue <= 255);

```c
// RGB Color Space
light_driver_set_rgb(uint8_t red, uint8_t green, uint8_t blue);
// HSL Color Space
light_driver_set_hsl(uint16_t hue, uint8_t saturation, uint8_t lightness);
// HSV Color Space
light_driver_set_hsv(uint16_t hue, uint8_t saturation, uint8_t value);
```

## LED 状态保存

当 LED 灯关灯后，下一次上电时，可能希望 LED 灯能恢复到之前的颜色、亮度状态。为了实现这个功能，需要在每次控制 LED 灯之后保存 LED 灯的状态，并且需要在驱动初始化的时候重新加载 LED 灯的状态。LED 状态保存功能在 light_driver 组件中已经完成了。

```c
// Save the status of LED
if (app_storage_get(LIGHT_STATUS_STORE_KEY, &g_light_status, sizeof(light_status_t)) != ESP_OK) {
    // ToDo
}

// Load the status of LED
if (app_storage_set(LIGHT_STATUS_STORE_KEY, &g_light_status, sizeof(light_status_t)) != ESP_OK) {
    // ToDO
}
```
