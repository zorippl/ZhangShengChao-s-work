### 9.4 设备的配网和绑定
您已经获得了 RainMaker 账号的 `accesstoken` 和 `user_id`，接下来您需要找到设备，让设备连上路由器，并在云端激活。

#### 9.4.1 扫描设备信号
##### 9.4.1.1 Android 扫描设备
```kotlin
ESPProvisionManager.getInstance(context)
    .searchBleEspDevices("prefix", object : BleScanListener {
        override fun scanStartFailed() {
            // 扫描失败
        }

        override fun onPeripheralFound(device: BluetoothDevice, scanResult: ScanResult) {
            // 扫描到设备
        }

        override fun scanCompleted() {
            // 扫描结束
        }

        override fun onFailure(e: Exception) {
            // 扫描出错
        }
    })
```
##### 9.4.1.2 iOS 扫描设备
```swift
ESPProvisionManager.shared.searchESPDevices(devicePrefix:"prefix", transport:.ble, security:.secure) { deviceList, _ in
    // 获取扫描结果
}
```

#### 9.4.2 与设备建立连接
##### 9.4.2.1 Android 与设备建立连接
在 Activity 中注册 BLE 连接状态回调
```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    ...
    EventBus.getDefault().register(this)
}

override fun onDestroy() {
    super.onDestroy()

    ...
    EventBus.getDefault().unregister(this)
}

@Subscribe()
fun deviceConnectionCallabck(event: DeviceConnectionEvent) {
    val connection = event.eventType
    // 连接状态见 ESPConstants 内的 Event types
    if (connection == ESPConstants.EVENT_DEVICE_CONNECTED) {
        // 连接成功，下一步获取设备 node id
    }
}
```

调用连接接口
```kotlin
val espDevice = ESPProvisionManager.getInstance(context)
    .createESPDevice(
        ESPConstants.TransportType.TRANSPORT_BLE,
        ESPConstants.SecurityType.SECURITY_1
    )
espDevice.bluetoothDevice = scanResult.device
espDevice.primaryServiceUuid = scanResult.scanRecord?.serviceUuids?.firstOrNull()?.toString()
espDevice.deviceName = scanResult.device.name
espDevice.connectToDevice()
```
##### 9.4.2.2 iOS 与设备建立连接
调用连接接口
```swift
espDevice.connect(delegate: self) { status in
    switch status {
    case .connected:
        // 连接成功，下一步获取设备 node id
    default:
        // 连接失败
    }
}
```

#### 9.4.3 生成 secret key 以及获取设备的 node id
secret key 和 node id 用于后续您的账号和设备在云端绑定
##### 9.4.3.1 Android 生成 secret key 和 获取设备 node id
```kotlin
var nodeId = ""
val secretKey = UUID.randomUUID().toString()
val deviceSecretRequest = EspRmakerUserMapping.CmdSetUserMapping.newBuilder()
    .setUserID(userId)
    .setSecretKey(secretKey)
    .build()
val msgType = EspRmakerUserMapping.RMakerConfigMsgType.TypeCmdSetUserMapping
val requestPayload = EspRmakerUserMapping.RMakerConfigPayload.newBuilder()
    .setMsg(msgType)
    .setCmdSetUserMapping(deviceSecretRequest)
    .build()
espDevice.sendDataToCustomEndPoint(
    Const.HandlerRmUserMapping,
    requestPayload.toByteArray(),
    object : ResponseListener {
        override fun onSuccess(returnData: ByteArray) {
            try {
                val responsePayload =
                    EspRmakerUserMapping.RMakerConfigPayload.parseFrom(returnData)
                val response = responsePayload.respSetUserMapping
                if (response.status == EspRmakerUserMapping.RMakerConfigStatus.Success) {
                    nodeId = response.nodeId
                    // 获得 node id 成功，下一步调用设备配网
                }
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        override fun onFailure(e: Exception) {
            e.printStackTrace()
        }
    }
)
```
##### 9.4.3.2 iOS 生成 secret key 和 获取设备 node id
```swift
do {
    var nodeId = ""
    let secretKey = UUID().uuidString

    let payloadData = try createAssociationConfigRequest()
    if let data = payloadData {
        espDevice.sendData(path: Constants.associationPath, data: data) { response, error in
            guard error == nil, response != nil else {
                return
            }

            self.processResponse(responseData: response!)
        }
    }
} catch {
}

```
```swift
private func createAssociationConfigRequest() throws -> Data? {
    var configRequest = Rainmaker_CmdSetUserMapping()
    configRequest.secretKey = secretKey
    configRequest.userID = User.shared.userInfo.userID
    var payload = Rainmaker_RMakerConfigPayload()
    payload.msg = Rainmaker_RMakerConfigMsgType.typeCmdSetUserMapping
    payload.cmdSetUserMapping = configRequest
    return try payload.serializedData()
}
```
```swift
func processResponse(responseData: Data) {
    do {
        let response = try Rainmaker_RMakerConfigPayload(serializedData: responseData)
        if response.respSetUserMapping.status == .success {
            nodeId = response.respSetUserMapping.nodeID
            // 获得 node id 成功，下一步调用设备配网
        }
    } catch {
    }
}
```

#### 9.4.4 设备配网
让设备连上指定路由器并在云端激活
##### 9.4.4.1 Android 调用配网
```kotlin
espDevice.provision(ssid, password, object : ProvisionListener {
    override fun createSessionFailed(e: Exception) {
    }

    override fun wifiConfigSent() {
    }

    override fun wifiConfigFailed(e: Exception) {
    }

    override fun wifiConfigApplied() {
    }

    override fun wifiConfigApplyFailed(e: Exception) {
    }

    override fun provisioningFailedFromDevice(failureReason: ESPConstants.ProvisionFailureReason) {
    }

    override fun deviceProvisioningSuccess() {
        // 配网成功
    }

    override fun onProvisioningFailed(e: Exception) {
    }
})
```
##### 9.4.4.1 iOS 调用配网
```swift
espDevice.provision(ssid: ssid, passPhrase: passphrase) { status in
    switch status {
    case .success:
    // 配网成功
    case let .failure(error):
        switch error {
        case .configurationError:
        case .sessionError:
        case .wifiStatusDisconnected:
        default:
        }
    case .configApplied:
    }
}
```

#### 9.4.5 小结
您已经成功让设备连上云端，接下去让我们绑定您的账号和设备，实现设备的远程控制吧。